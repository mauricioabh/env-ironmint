import fs from "fs-extra";
const { writeFileSync, readFileSync, existsSync } = fs;
import { join } from "path";
import { EnvFile, SyncOptions } from "../types/index.js";
import chalk from "chalk";

export class EnvSync {
  /**
   * Sync .env files based on example file
   */
  static async syncEnvFile(
    options: SyncOptions
  ): Promise<{ success: boolean; message: string }> {
    try {
      // Read source file (.env.example)
      if (!existsSync(options.sourceFile)) {
        return {
          success: false,
          message: `Source file not found: ${options.sourceFile}`,
        };
      }

      const sourceContent = readFileSync(options.sourceFile, "utf-8");
      const sourceVariables = this.parseEnvContent(sourceContent);

      // Read target file if it exists
      let targetVariables: Record<string, string> = {};
      if (existsSync(options.targetFile)) {
        const targetContent = readFileSync(options.targetFile, "utf-8");
        targetVariables = this.parseEnvContent(targetContent);
      }

      // Merge variables
      const mergedVariables = { ...sourceVariables };

      if (options.preserveExisting) {
        // Keep existing values in target file
        Object.keys(targetVariables).forEach((key) => {
          if (targetVariables[key] && targetVariables[key].trim() !== "") {
            mergedVariables[key] = targetVariables[key];
          }
        });
      }

      // Fill empty values if requested
      if (options.fillEmpty) {
        Object.keys(mergedVariables).forEach((key) => {
          if (!mergedVariables[key] || mergedVariables[key].trim() === "") {
            mergedVariables[key] = `TODO_${key.toUpperCase()}`;
          }
        });
      }

      // Generate new content
      const newContent = this.generateEnvContent(mergedVariables);

      // Write target file
      writeFileSync(options.targetFile, newContent, "utf-8");

      return {
        success: true,
        message: `Successfully synced ${
          Object.keys(mergedVariables).length
        } variables to ${options.targetFile}`,
      };
    } catch (error) {
      return {
        success: false,
        message: `Error syncing files: ${
          error instanceof Error ? error.message : "Unknown error"
        }`,
      };
    }
  }

  /**
   * Parse .env file content
   */
  private static parseEnvContent(content: string): Record<string, string> {
    const variables: Record<string, string> = {};
    const lines = content.split("\n");

    for (const line of lines) {
      const trimmedLine = line.trim();

      // Skip empty lines and comments
      if (!trimmedLine || trimmedLine.startsWith("#")) {
        continue;
      }

      // Parse KEY=VALUE format
      const equalIndex = trimmedLine.indexOf("=");
      if (equalIndex > 0) {
        const key = trimmedLine.substring(0, equalIndex).trim();
        let value = trimmedLine.substring(equalIndex + 1).trim();

        // Remove quotes if present
        if (
          (value.startsWith('"') && value.endsWith('"')) ||
          (value.startsWith("'") && value.endsWith("'"))
        ) {
          value = value.slice(1, -1);
        }

        variables[key] = value;
      }
    }

    return variables;
  }

  /**
   * Generate .env file content from variables
   */
  private static generateEnvContent(variables: Record<string, string>): string {
    const lines: string[] = [];

    // Add header comment
    lines.push("# Environment variables");
    lines.push("# Generated by env-ironmint");
    lines.push("");

    // Add variables
    Object.entries(variables).forEach(([key, value]) => {
      // Quote value if it contains spaces or special characters
      const quotedValue = this.shouldQuoteValue(value) ? `"${value}"` : value;
      lines.push(`${key}=${quotedValue}`);
    });

    return lines.join("\n");
  }

  /**
   * Check if a value should be quoted
   */
  private static shouldQuoteValue(value: string): boolean {
    return (
      value.includes(" ") ||
      value.includes("#") ||
      value.includes("=") ||
      value.startsWith("$")
    );
  }

  /**
   * Format sync result
   */
  static formatSyncResult(result: {
    success: boolean;
    message: string;
  }): string {
    if (result.success) {
      return chalk.green(`✅ ${result.message}`);
    } else {
      return chalk.red(`❌ ${result.message}`);
    }
  }
}
